import express, { Application, Request, Response } from 'express';
import { createExpressServer } from 'routing-controllers';
import dotenv from 'dotenv';
import path from 'path';

import fs from 'fs/promises';
import pug from 'pug';
import axios from 'axios';
import { CVAdaptationService } from '../services/CVAdaptationService';

dotenv.config();

/**
 * Server class
 * @class
 */
export class Server {
  /** @type {express.Application} */
  private app: express.Application;
  /** @type {number} */
  private port: number;
  private readonly publicTemplatesDir: string;
  private readonly viewsDir: string;
  private cvAdaptationService: CVAdaptationService;

  /**
   * Server constructor
   * initializes express server
   * and sets listening port
   * @constructor
   * @returns void
   */
  public constructor() {
    this.app = createExpressServer({
      cors: true,
      defaultErrorHandler: false,
      controllers: [path.join(__dirname + '/../controllers/*.js')],
    });

    this.port = Number(process.env.PORT) || 3000;

    this.publicTemplatesDir = path.join(__dirname, '..', 'public', 'templates');
    this.viewsDir = path.join(__dirname, '..', 'views');
    this.cvAdaptationService = new CVAdaptationService();

    this.configureMiddleware();
    this.configureRoutes();
  }

  private configureMiddleware(): void {
    this.app.use(express.json());

    // Serve generated HTML files as static assets
    this.app.use('/templates', express.static(this.publicTemplatesDir));
  }

  private configureRoutes(): void {
    this.app.post(
      '/generate/template/:templateSlug',
      this.generateFromTemplate,
    );
    this.app.get('/generate/template/:templateSlug', this.generateFromTemplate);
    this.app.get('/templates/:templateSlug', this.serveHTML);

    // CV adaptation workflow endpoint
    this.app.post('/adapt-cv-workflow', this.adaptCVWorkflow);
  }

  /**
   * Listen method
   * @memberof Server
   * @returns void
   */
  public listen(): void {
    this.app.listen(this.port, () => {
      console.log(`Server running on port ${this.port}`);
    });
  }

  /**
   * generateFromTemplate
   *
   * - Renders a Pug template identified by :templateSlug with JSON POST body
   * - Saves HTML under public/templates/[templateSlug].html
   * - Calls Gotenberg to convert that URL into a PDF and returns the PDF
   */
  private generateFromTemplate = async (req: Request, res: Response) => {
    const templateSlug = req.params.templateSlug;

    const ENV_APP_URL =
      process.env.ENV_APP_URL || `http://localhost:${this.port}`;
    const ENV_GOTENBERG_URL = process.env.ENV_GOTENBERG_URL;

    console.log('req.body', req.body);

    if (!ENV_GOTENBERG_URL) {
      return res
        .status(500)
        .json({ error: 'ENV_GOTENBERG_URL must be defined' });
    }

    try {
      // 1. Render the Pug template with the JSON body as locals
      const pugPath = path.join(this.viewsDir, `${templateSlug}.pug`);
      const htmlFromPug = pug.renderFile(pugPath, req.body || {});

      // 2. Save HTML to public/templates/[templateSlug].html
      const htmlFilePath = path.join(
        this.publicTemplatesDir,
        `${templateSlug}.html`,
      );

      await fs.mkdir(path.dirname(htmlFilePath), { recursive: true });
      await fs.writeFile(htmlFilePath, htmlFromPug, 'utf8');

      // 3. Build URL to the generated HTML
      const htmlUrl = `${ENV_APP_URL}/templates/${templateSlug}`;

      // 4. Call Gotenberg (curl equivalent)
      const gotenbergEndpoint = `${ENV_GOTENBERG_URL}/forms/chromium/convert/url`;
      const form = new FormData();
      form.append('url', htmlUrl);

      console.log('gotenbergEndpoint', gotenbergEndpoint);
      console.log('htmlUrl', htmlUrl);

      // Use axios with native FormData
      const gotenbergResponse = await axios.post(gotenbergEndpoint, form, {
        responseType: 'arraybuffer',
      });

      const pdfBuffer = Buffer.from(gotenbergResponse.data);

      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader(
        'Content-Disposition',
        `attachment; filename="${templateSlug}.pdf"`,
      );
      return res.send(pdfBuffer);
    } catch (err: any) {
      console.error('generateFromTemplate error:', err);
      return res.status(500).json({
        error: 'Failed to generate template',
        details: err?.message ?? String(err),
      });
    }
  };

  /**
   * serveHTML
   * GET {ENV_APP_URL}/templates/:templateSlug.html
   *
   * Serves the HTML generated by generateFromTemplate()
   */
  private serveHTML = async (req: Request, res: Response) => {
    const templateSlug = req.params.templateSlug;
    const htmlFilePath = path.join(
      this.publicTemplatesDir,
      `${templateSlug}.html`,
    );

    try {
      await fs.access(htmlFilePath);
      return res.sendFile(htmlFilePath);
    } catch {
      return res.status(404).send('Generated template not found');
    }
  };

  /**
   * adaptCVWorkflow
   * POST /adapt-cv-workflow
   *
   * Complete workflow that:
   * 1. Takes CV data and job offer data
   * 2. Uses OpenAI to adapt the CV to the job offer
   * 3. Generates a PDF from the adapted CV using the template
   *
   * Request body:
   * {
   *   cv: CVData,
   *   jobOffer: JobOfferData,
   *   sessionId?: string,
   *   templateSlug?: string
   * }
   */
  private adaptCVWorkflow = async (req: Request, res: Response) => {
    const {
      cv,
      jobOffer,
      sessionId = 'default',
      templateSlug = 'test',
    } = req.body;

    // Validate required fields
    if (!cv || !jobOffer) {
      return res.status(400).json({
        error: 'Missing required fields: cv and jobOffer are required',
      });
    }

    try {
      console.log('Step 1: Adapting CV with OpenAI...');

      // Step 1: Adapt CV using OpenAI
      const adaptedCV = await this.cvAdaptationService.adaptCV({
        cv,
        jobOffer,
        sessionId,
      });

      console.log('Step 2: Generating PDF from adapted CV...');

      // Step 2: Generate PDF using the template endpoint logic
      const ENV_APP_URL =
        process.env.ENV_APP_URL || `http://localhost:${this.port}`;
      const ENV_GOTENBERG_URL = process.env.ENV_GOTENBERG_URL;

      if (!ENV_GOTENBERG_URL) {
        return res
          .status(500)
          .json({ error: 'ENV_GOTENBERG_URL must be defined' });
      }

      // Render the Pug template with the adapted CV
      const pugPath = path.join(this.viewsDir, `${templateSlug}.pug`);
      const htmlFromPug = pug.renderFile(pugPath, { cv: adaptedCV });

      // Save HTML to public/templates/[templateSlug].html
      const htmlFilePath = path.join(
        this.publicTemplatesDir,
        `${templateSlug}.html`,
      );

      await fs.mkdir(path.dirname(htmlFilePath), { recursive: true });
      await fs.writeFile(htmlFilePath, htmlFromPug, 'utf8');

      // Build URL to the generated HTML
      const htmlUrl = `${ENV_APP_URL}/templates/${templateSlug}`;

      // Call Gotenberg to convert HTML to PDF
      const gotenbergEndpoint = `${ENV_GOTENBERG_URL}/forms/chromium/convert/url`;
      const form = new FormData();
      form.append('url', htmlUrl);

      console.log('Step 3: Converting HTML to PDF with Gotenberg...');
      console.log('Gotenberg endpoint:', gotenbergEndpoint);
      console.log('HTML URL:', htmlUrl);

      const gotenbergResponse = await axios.post(gotenbergEndpoint, form, {
        responseType: 'arraybuffer',
      });

      const pdfBuffer = Buffer.from(gotenbergResponse.data);

      // Return the PDF
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader(
        'Content-Disposition',
        `attachment; filename="cv-adapted-${Date.now()}.pdf"`,
      );

      console.log('Workflow completed successfully!');
      return res.send(pdfBuffer);
    } catch (err: any) {
      console.error('adaptCVWorkflow error:', err);
      return res.status(500).json({
        error: 'Failed to complete CV adaptation workflow',
        details: err?.message ?? String(err),
      });
    }
  };
}
